// Code is generated by Telerik Data Access Service Wizard
// using WebApiController.tt template

using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Threading.Tasks;
using System.Web;
using System.Web.Http;
using System.Web.Http.OData;
using MyERP.DataAccess;
using Telerik.OpenAccess;
using Telerik.OpenAccess.Data.Common;

namespace MyERP.Web
{
    /// <summary>
    /// Web API Controller for Accounts entity defined in MyERP.DataAccess.EntitiesModel data model
    /// </summary>

    public partial class NumberSequencesController 
    {
        public SingleResult<NumberSequence> GetNumberSequence([FromODataUri] Guid key)
        {
            return SingleResult.Create(repository.GetAll().Where(c => c.Id == key).AsQueryable());
        }


        /// <summary>
        /// Updates single entity.
        /// </summary>
        /// <remarks>Replaces the whole existing entity with the provided one</remarks>
        /// <param name="key">ID of the entity to update</param>
        /// <param name="entity">Entity with the new updated values</param>
        /// <returns>HttpStatusCode.BadRequest if ID parameter does not match the ID value of the entity,
        /// or HttpStatusCode.NoContent if the operation was successful</returns>
        public IHttpActionResult PutNumberSequence([FromODataUri] Guid key, MyERP.DataAccess.NumberSequence entity)
        {
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }

            if (entity == null || key != entity.Id)
                return BadRequest();

            repository.Update(entity);

            return Updated(entity);
        }

        [AcceptVerbs("PATCH", "MERGE")]
        public IHttpActionResult Patch([FromODataUri] Guid key, Delta<MyERP.DataAccess.NumberSequence> patch)
        {
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }

            NumberSequence entity = repository.GetBy(c => c.Id == key);
            if (entity == null)
            {
                return NotFound();
            }

            patch.Patch(entity);

            try
            {
                repository.Update(entity);
            }
            catch (Telerik.OpenAccess.Exceptions.OptimisticVerificationException e)
            {
                if (repository.GetBy(c => c.Id == key) == null)
                {
                    return NotFound();
                }
                else
                {
                    throw;
                }
            }

            return Updated(entity);
        }

        /// <summary>
        /// Deletes an entity by it's ID
        /// </summary>
        /// <param name="key">ID of the entity to delete</param>
        /// <returns>Always HttpStatusCode.OK</returns>
        public IHttpActionResult DeleteNumberSequence([FromODataUri] Guid key)
        {
            MyERP.DataAccess.NumberSequence entity = repository.GetBy(m => m.Id == key);
            if (entity != null)
            {
                try
                {
                    string SqlQuery = String.Format("DROP SEQUENCE {0};", new object[] { entity.NoSeqName });
                    // 3. Create a new instance of the OACommand class.
                    using (var command = repository.DataContext.Connection.CreateCommand())
                    {
                        command.CommandText = SqlQuery;
                        command.ExecuteNonQuery();
                    }

                    repository.Delete(entity);

                }
                catch (Exception)
                {
                    throw;
                }
                
            }

            // According to the HTTP specification, the DELETE method must be idempotent, 
            // meaning that several DELETE requests to the same URI must have the same effect as a single DELETE request. 
            // Therefore, the method should not return an error code if the product was already deleted.
            return StatusCode(HttpStatusCode.NoContent);
        }

        /// <summary>
        /// Creates a new entity based on the provided data
        /// </summary>
        /// <param name="entity">The new entity to be created</param>
        /// <returns>HTTP Status:
        /// - Accepted when operation is successful or 
        /// - MethodNotAllowed if the operation is disabled for this entity or
        /// - BadRequest if the provided entity is NULL</returns>
        public IHttpActionResult PostNumberSequence(NumberSequence entity)
        {
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }

            try
            {
                string SqlQuery = String.Format("CREATE SEQUENCE {0} MINVALUE {1} MAXVALUE {2} START {3};",
                    new object[] {entity.NoSeqName, entity.StartingNo, entity.EndingNo, entity.CurrentNo});
                // 3. Create a new instance of the OACommand class.
                using (var command = repository.DataContext.Connection.CreateCommand())
                {
                    command.CommandText = SqlQuery;
                    command.ExecuteNonQuery();
                }
                NumberSequence newEntity = repository.AddNew(entity);
                return Created(newEntity);
            }
            catch (Exception)
            {
                throw;
            }
        }

        public IHttpActionResult SequenceNextVal([FromODataUri] Guid key)
        {
            NumberSequence numberSequence = repository.GetAll().FirstOrDefault(c => c.Id == key);
            if (numberSequence == null)
            {
                return NotFound();
            }

            int sequenceNextVal = 0;
            // 2. Initialize the sql query.
            string SqlQuery = String.Format("SELECT nextval('{0}')", new object[] {numberSequence.NoSeqName});

            // 3. Create a new instance of the OACommand class.
            using (var command = repository.DataContext.Connection.CreateCommand())
            {
                command.CommandText = SqlQuery;

                // 4. Execute the command and retrieve the scalar values.
                sequenceNextVal = Convert.ToInt32(command.ExecuteScalar());
            }

            return Ok(sequenceNextVal);
        }
    }
}
